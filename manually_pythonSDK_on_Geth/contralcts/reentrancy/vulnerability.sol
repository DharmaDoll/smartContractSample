pragma solidity ^0.8.18;

contract VictimBalance{
    //アドレス毎に残高を管理
    mapping(address=>uint) public userBalances;
    address public owner;

    //メッセージ表示用のイベント
    event MessageLog(string);
    //残高表示用のイベント
    event BalanceLog(uint);

    ///コンストラクタ
    // function VictimBalance(){}
    /// オーナーを設定
     constructor(){
         owner = msg.sender;
     }

    ///送金される際に呼ばれる関数
    function addToBalance() public payable {
        userBalances[msg.sender] += msg.value;
    }

    ///etherを引き出す時に呼ばれる関数
    function withdrawBalance() public payable returns(bool){
        emit MessageLog("with draw Balance started.");
        emit BalanceLog(address(this).balance);
        // BalanceLog(this.balance);
        //①残高を確認
        if(userBalances[msg.sender] == 0){
            emit MessageLog("No Balance.");
            return false;
        }

        //②呼び出し元に返金
        //次の処理が呼ばれると、攻撃コントラクトのFallback関数が呼び出されます。
        // if(!(msg.sender.call.value(userBalances[msg.sender])())){
        (bool success, bytes memory response) = msg.sender.call{value:userBalances[msg.sender]}("");
        if(!success){
             revert();
            // throw; 最新のsolidity versionだとコンパイルエラーになる
        }

        ////修正コード
        //②残高更新前に送金額を退避 uint amount=userBalances[msg.sender];
        //③残高を更新 userBalances[msg.sender]=0;
        //④呼び出し元に返金 if(!(msg.sender.call.value(amount)())){throw;}
        ////

        //③残高を更新  
        userBalances[msg.sender] = 0;
        emit MessageLog("withdraw Balance finished.");
        return true;
    }
}